#!/usr/bin/env python3

from __future__ import print_function

import argparse
import requests.exceptions
import sys
import time
import argcomplete
import toml
import os

from datetime import datetime
from operator import attrgetter
from commands import *

from api import PDNSAPI


class PDNSClient(object):

    @property
    def commands(self):
        """
        A dict of all command modules indexed with their name.
        """
        return {klass.name(): klass for klass in PDNSCommand.__subclasses__()}

    def run(self):
        """
        Main execution path.

        Roughly - load all command module klasses into the command map

        Parse the cli args using argparse (including command module subparsers)

        Load the config file if one can be found

        Merge the cli args and config file args

        TODO: validate we have required arguments (from config or cli)

        Setup the API and execute the appropriate command module
        """

        self.load_modules()

        self.parse_cli_args()

        self.load_config_file()

        # This is None when no config file was found/available/specified etc
        if self.config_path:
            self.generate_zone_map()
            self.combine_cli_args_and_config()

        if self.args.auth:
            auth = tuple(self.args.auth.split(':', 1))
        else:
            auth = None

        self.api = PDNSAPI(self.args.url, verify=(not self.args.insecure),
                           basic_auth=auth, api_key=self.args.api_key)

        # Look up the action to see if it's implemented in a module, or raise an error
        if self.args.action in self.cmd_map:
            moduleklass = self.cmd_map[self.args.action]
            # instance and pass in args and API instance
            module = moduleklass(self.args, self.api)
            # TODO better error handling
            try:
                module.run()
            except requests.exceptions.HTTPError as e:
                if e.response.status_code == 422 and 'error' in e.response.json():
                    sys.stderr.write('API error: {}\n'.format(e.response.json()['error']))
                else:
                    sys.stderr.write('HTTP error: {}\n'.format(e))

        else:
            sys.stderr.write('FIXME: {}: action not implemented\n'.format(self.args.action))
            sys.exit(1)

    def load_modules(self):
        """
        Create a map of the action subparser cmd to the class that implements
        that command
        """
        self.cmd_map = dict()
        for modulename, moduleklass in self.commands.items():
            for command in moduleklass.COMMANDS:
                self.cmd_map[command] = moduleklass

    def combine_cli_args_and_config(self):
        """
        Combine the cli args and configs provided by the config file (if any)
        CLI args always take priority over config in all instances
        """
        if self.config['api']:
            api = self.config['api']
        else:
            sys.stderr.write('No api section in config file, please check the config file and try again')
            return

        if api['url'] and not self.args.url:
            self.args.url = api['url']

        if api['default-server'] and not self.args.server:
            self.args.server = api['default-server']

        auth = None
        # TODO check user exists and stderr if not set
        final_user_conf = self.config[api['default-user']]

        # If a zone is given and this zone has a mapped api user load that user from conf file
        if 'zone' in self.args and (self.args.zone in self.zone_map):
            final_user_conf = self.zone_map[self.args.zone]
            final_user_conf = self.config[final_user_conf]

        if final_user_conf and not self.args.auth and ('user' in final_user_conf and 'key' in final_user_conf):
            self.args.auth = '{}:{}'.format(final_user_conf['user'], final_user_conf['key'])

    def load_config_file(self):
        """
        Load config file from either envvar or commandline option (higher priority)
        """
        self.config = None
        self.config_path = None
        if 'PDNS_CLI_CONF_PATH' in os.environ:
            self.config_path = os.environ['PDNS_CLI_CONF_PATH']

        if self.args.config_path:
            self.config_path = self.args.config_path

        if self.config_path:
            self.config = toml.load(self.config_path)

    def generate_zone_map(self):
        """
        Given the conf dict, search for keys that start with user and retreive their zones
        attribute, then iterate through it and create a new mapping of zone -> full user key
        we can then look this up later when deciding what user/key to use for the api call
        """
        self.zone_map = dict()
        for key, dictmap in self.config.items():
            if key.startswith('user'):
                if 'zones' in dictmap:
                    for zone in dictmap['zones']:
                        self.zone_map[zone] = key

    def parse_cli_args(self):
        """
        Command line argument processing and autocompletion.
        """

        # Top level parser arguments
        parser = argparse.ArgumentParser(description='CLI client for the PowerDNS API')
        parser.add_argument('-a', '--auth', metavar='USERNAME:PASSWORD', help='credentials for Basic authentication')
        parser.add_argument('-k', '--api-key', help='API key')
        parser.add_argument('-i', '--insecure', action='store_true', help='allow insecure TLS connections')
        parser.add_argument('-c', '--config-path', help='give a different config file path')
        parser.add_argument('-u', '--url', help='PowerDNS API URL')
        parser.add_argument('-s', '--server', help='server ID')


        subparsers = parser.add_subparsers(title='actions', metavar='action', dest='action')
        subparsers.required = True

        zone_parser = argparse.ArgumentParser(add_help=False)
        zone_parser.add_argument('zone', help='zone ID')

        for modulename, moduleklass in self.commands.items():
            moduleklass.init_parser(subparsers, zone_parser)

        argcomplete.autocomplete(parser)
        self.args = parser.parse_args()

    def fail(self, msg):
        sys.stderr.write('error: {}\n'.format(msg))
        sys.exit(1)

    def list_config(self, args):
        server = self.api.server(self.args.server)

        for setting in sorted(server.config, key=attrgetter('id')):
            print('{}: {}'.format(setting.data['name'], setting.data['value']))

if __name__ == '__main__':
    pdns_client = PDNSClient()
    pdns_client.run()
